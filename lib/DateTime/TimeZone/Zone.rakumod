unit role DateTime::TimeZone::Zone;

## A foundation for all DateTime::TimeZone::Zone::* classes.
## The DateTime::TimeZone::Zone::* classes will be generated by a script,
## using the DateTime::Olson library.

has DateTime $.datetime;     ## The DateTime object used to determine offset from.

method !time-to-offset(Str:D $time) {
    if $time eq '0' | '0:00' {
        0
    }
    else {
        my (int $hours, int $minutes) = $time.split(":").map: *.Int;
        my int $seconds = $hours * 60 * 60;
        $minutes
          ?? $seconds < 0
            ?? $seconds - ($minutes * 60)
            !! $seconds + ($minutes * 60)
          !! $seconds
    }
}

method !apply-rules(@rules) {
    my $change;
    my $max-dt;
    my $year    := $!datetime.year;
    my $instant := $!datetime.Instant;

    for @rules -> %rule {
        if $year ~~ %rule<years> {
            my $datetime;

            my ($hour,$minute) = split(/\:/, %rule<time>);
            $hour   .= Int;
            $minute .= Int;

            if %rule<date> -> $day {
                $datetime = DateTime.new: :$year,
                  :month(%rule<month>), :$day, :$hour, :$minute;
            }
            elsif %rule<lastdow> -> $lastdow {
                $datetime = DateTime.new: :$year,
                  :month(%rule<month>), :day(1), :$hour, :$minute;

                my $days;
                my $day-of-week := $datetime.day-of-week;
                if $day-of-week <= $lastdow {
                    $days = $lastdow - $day-of-week;
                }
                else {
                    $days = 7 - ($day-of-week - $lastdow);
                }
                $datetime .= later(:$days);

                loop {
                    my $new-dt = $datetime.later(weeks => 1);
                    if $new-dt.month == $datetime.month {
                        $datetime = $new-dt;
                    }
                    else {
                        last;
                    }
                }
            }
            elsif %rule<dow> -> ($dow, $mindate) {
                $datetime = DateTime.new: :$year,
                  :month(%rule<month>), :day(1), :$hour, :$minute;
                my $day-of-week := $datetime.day-of-week;
                my $days = $day-of-week <= $dow
                  ?? $dow - $day-of-week
                  !! 7 - ($day-of-week - $dow);
                $days += 7 while $days < $mindate;
                $datetime .= later(:$days);
            }

            if $instant >= $datetime.Instant {
                if !$max-dt || $datetime.Instant > $max-dt.Instant {
                    $max-dt = $datetime;
                    $change = %rule<adjust>;
                }
            }
        }
    }

    $change ?? self!time-to-offset($change) !! 0
}

method offset() {
#    my %best-zone-entry;
#    my $best-until = Inf;
#    my $time := $!datetime.posix;
#    for @.zonedata -> %zone-entry {
#        my $zone-until := %zone-entry<until>;
#        if $zone-until > $time {
#            if $zone-until <= $best-until {
#                %best-zone-entry := %zone-entry;
#                $best-until       = $zone-until;
#            }
#        }
#    }

    my $time := $!datetime.posix;
    my %best-zone-entry;
    if @.zonedata -> @zone-data {
        %best-zone-entry := @zone-data.first: -> %zone-entry {
            $time < (%zone-entry<until> // Inf)
        }
    }

    my int $offset;
    $offset = self!time-to-offset($_) with %best-zone-entry<baseoffset>;
    my $rule-id := %best-zone-entry<rules>;
    if $rule-id && %.rules{$rule-id} -> @rules {
        $offset + self!apply-rules(@rules)
    }
    else {
        $offset
    }
}

## The rest are convenience wrappers for converting the object to a number.

method gist() { self.name }
method Str()  { self.name }
method Int() { self.offset.Int }
method Num() { self.offset.Num }
method Numeric() { self.offset }

# vim: expandtab shiftwidth=4
